# Значения словаря, принимаемые по умолчанию

name_for_userid = {
    382: 'Элис',
    950: 'Боб',
    590: 'Дилберт',
}


def greeting(userid):
    return 'Привет, %s!' % name_for_userid[userid]

# НО еси ключа нет то будет ошибка
# greeting(33333333)
# KeyError: 33333333

#  для утсранения можно использовать функцию get, с указанием значения по умоляанию на случай если нет ключа
def greeting(userid):
    return 'Привет, %s!' % name_for_userid.get(userid, 'всем')

# Сортировка словарей для дела и веселья
xs = {'a': 4, 'c': 2, 'b': 3, 'd': 1}

# сортировка по ключам
print(sorted(xs.items()))

# сортировка по значениям
print(sorted(xs.items(), key=lambda x: x[1]))

# или так (там есть еще ключи)
import operator
sorted(xs.items(), key=operator.itemgetter(1))
# [('d', 1), ('c', 2), ('b', 3), ('a', 4)]


# отсортировать словарь на основе
# абсолютной числовой величины каждого хранящегося в нем значения:
print(sorted(xs.items(), key=lambda x: abs(x[1])))

# Если вам нужно инвертировать порядок сортировки
print(sorted(xs.items(),
             key=lambda x: x[1],
             reverse=True
             )
      )

# -------------Имитация инструкций выбора на основе словарей--------
# Как реализовать структуру (в языке ее нет) инструкций выбора switch-case
# Так как функции это объекты, то
def my_func(a, b):
    return a + b

funcs = [my_func, my_func]

print(funcs[1]( 1, 2))
#  то можно сделать словарь из функций и вызывать их через get с одной функцией на случий отсутсвия ключа всловаре
def handle_a():
    pass

def handle_b():
    pass

def handle_default():
    pass

func_dict = {
    'cond_a': handle_a,
    'cond_b': handle_b
}

cond = 'cond_a'
func_dict.get(cond, handle_default)()

# другой вариант
# оригинал
def dispatch_if(operator, x, y):
    if operator == 'add':
        return x + y
    elif operator == 'sub':
        return x - y
    elif operator == 'mul':
        return x * y
    elif operator == 'div':
        return x / y
    # return None

# усовершентсвуем (также можно использовть operator.mul или add итд)
def dispatch_dict(operator, x, y):
    return {
        'add': lambda: x + y,
        'sub': lambda: x - y,
        'mul': lambda: x * y,
        'div': lambda: x / y,
    }.get(operator, lambda: None)()

print(dispatch_dict('mul', 2, 8))
# 16
dispatch_dict('неизвестно', 2, 8)
# None


# -------------------7 .4 . Самое сумасшедшее выражение-словарь на западе ------------
print({True: 'да', 1: 'нет', 1.0: 'возможно'})
# {True: 'возможно'}

# ОКАЗЫВАЕТСЯ
# >>> xs = dict()
# >>> xs[True] = 'да'
# >>> xs[1] = 'нет'
# >>> xs[1.0] = 'возможно'
# Как ни странно, Python считает все ключи, используемые в этом примере словаря, эквивалентными:
# >>> True == 1 == 1.0
# True
# Python рас- сматривает тип bool как подкласс типа int
# все эти значения — True, 1 и 1.0 — пред- ставляют одинаковый ключ словаря. Когда интерпретатор вычисляет
# вы- ражение-словарь, он неоднократно переписывает значение ключа True.
# Итак: Выражение-словарь {True: 'да', 1: 'нет', 1.0: 'возможно'} вычисляется как {True: 'возможно'},
# потому что сравнение всех ключей этого примера, True, 1, и 1.0, будет показывать их как эквивалентные друг другу, и они все имеют одинаковое хеш-значение:
# >>> True == 1 == 1.0
# True
# >>> (hash(True), hash(1), hash(1.0))
# (1, 1, 1)

# ----------------Так много способов объединить словари-----------

xs = {'a': 1, 'b': 2}
ys = {'b': 3, 'c': 4}

# если вы внимательно прочли этот пример, то вы заметили, что строка 'b' появляется в качестве ключа в обоих словарях,
# — нам также придется продумать стратегию раз- решения конфликтов для повторяющихся ключей

# вариант1
zx ={}
zx.update(xs)
zx.update(ys)
print(zx)
# {'a': 1, 'b': 3, 'c': 4}
# # вот что делает функция update
# def update(dict1, dict2):
#      for key, value in dict2.items():
#           dict1[key] = value

# вариант 2 использует встроенную функцию dict() совместно с оператором ** для «распаковки» объектов:
zx = dict(xs, **ys)
# вариант 3
# более приятный — способ объединения произвольного количества словарей:
zx = {**xs, **ys}
print(zx)
# самую стратегию разрешения конфликтов: правая сторона имеет приоритет, а значение в ys переопределяет
# любое существующее значение под тем же самым ключом в xs

# ---------------Структурная печать словаря-------------
# вариант 1
mapping = {'a': 23, 'b': 42, 'c': 0xc0ffee}
print(str(mapping))
# {'b': 42, 'c': 12648430, 'a': 23}

# вариант 2
import json
print(json.dumps(mapping, indent=4, sort_keys=True,))

# вы столкнетесь с проблемой при попытке распечатать словарь, который содержит непримитивный тип данных,
# таких как функция:
# json.dumps({all: 'yup'})
# TypeError: "keys must be a string"
# Еще один недостаток использования функции json.dumps() состоит в том, что она не способна сериализовать
# составные типы данных, такие как множества:
mapping['d'] = {1, 2, 3}
# json.dumps(mapping)
# TypeError: "set([1, 2, 3]) is not JSON serializable"

# вариант 3
import pprint
pprint.pprint(mapping)

